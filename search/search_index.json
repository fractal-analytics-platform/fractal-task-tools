{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to Fractal Command-line Client's documentation!","text":"<p>Fractal is a framework developed at the BioVisionCenter to process bioimaging data at scale in the OME-Zarr format and prepare the images for interactive visualization.</p> <p>This documentation concerns the Fractal Task Tools package, which provides some basic tools for building tasks for the Fractal framework. Find more information about Fractal in general and the other repositories at the Fractal home page.</p> <p>This project is under active development \ud83d\udd28. If you need help or found a bug, open an issue here.</p>"},{"location":"#contributors-and-license","title":"Contributors and license","text":"<p>Fractal was conceived in the Liberali Lab at the Friedrich Miescher Institute for Biomedical Research and in the Pelkmans Lab at the University of Zurich by @jluethi and @gusqgm. The Fractal project is now developed at the BioVisionCenter at the University of Zurich and the project lead is with @jluethi. The core development is done under contract by eXact lab S.r.l..</p> <p>Unless otherwise specified, Fractal components are released under the BSD 3-Clause License, and copyright is with the BioVisionCenter at the University of Zurich.</p>"},{"location":"changelog/","title":"Changelog","text":""},{"location":"changelog/#010","title":"0.1.0","text":"<p>First version tracked in this CHANGELOG.</p>"},{"location":"development/","title":"Contribute to Fractal Task Tools development","text":"<pre><code>$ python -m venv venv\n\n$ source venv/bin/activate\n\n$ python -m pip install -e .[dev]\n[...]\nSuccessfully installed asttokens-2.4.1 bumpver-2024.1130 click-8.1.8 colorama-0.4.6 coverage-7.6.12 devtools-0.12.2 exceptiongroup-1.2.2 executing-2.2.0 fractal-task-tools-0.0.1 iniconfig-2.0.0 lexid-2021.1006 packaging-24.2 pluggy-1.5.0 pygments-2.19.1 pytest-8.3.5 six-1.17.0 toml-0.10.2 tomli-2.2.1\n\n$ pre-commit install\npre-commit installed at .git/hooks/pre-commit\n</code></pre>"},{"location":"development/#how-to-make-a-release","title":"How to make a release","text":"<p>From the development environment: <pre><code>bumpver update --patch --dry\n</code></pre></p>"},{"location":"development/#tests","title":"Tests","text":"<p>Run e.g. one of these commands <pre><code>pytest\npytest -s -vvv --log-cli-level info --full-trace\n</code></pre></p>"},{"location":"development/#documentation","title":"Documentation","text":"<p>The documentation is built with mkdocs, and we bundle a module from sphinx-argparse plugin, customized to our needs.</p> <p>To build or server the documentation locally run <pre><code>mkdocs serve --config-file mkdocs.yml  # serves the docs at http://127.0.0.1:8000\n\nmkdocs build --config-file mkdocs.yml  # creates a build in the `site` folder\n</code></pre></p>"},{"location":"usage/","title":"Install <code>fractal-tasks-tools</code>","text":"<p>Fractal Task Tools is hosted on the PyPI index, and it can be installed with <code>pip</code> via <pre><code>pip install fractal-task-tools\n</code></pre></p>"},{"location":"usage/#use-fractal-tasks-tools","title":"Use <code>fractal-tasks-tools</code>","text":""},{"location":"usage/#build-tasks-manifest","title":"Build tasks manifest","text":"<p>-- IN PROGRESS --</p> <p>See details about:</p> <ul> <li>The <code>fractal-manifest</code> command-line interface.</li> <li>The task models to be used in <code>task_list.py</code>.</li> </ul>"},{"location":"usage/#run-tasks","title":"Run tasks","text":"<p>-- IN PROGRESS --</p>"},{"location":"usage/#migrate-from-fractal-tasks-core","title":"Migrate from <code>fractal-tasks-core</code>","text":""},{"location":"usage/#build-tasks-manifest_1","title":"Build tasks manifest","text":"<ol> <li> <p>In the <code>task_list.py</code> file of your package, replace <code>import</code>s from <code>fractal_tasks_core.dev.task_models</code> with <pre><code>from fractal_task_tools.task_models import CompoundTask\nfrom fractal_task_tools.task_models import NonParallelTask\nfrom fractal_task_tools.task_models import ParallelTask\n</code></pre></p> </li> <li> <p>In the <code>task_list.py</code> file of your package, include <code>AUTHORS</code>, <code>DOCS_LINK</code> and <code>INPUT_MODELS</code> (if applicable), as in this example: <pre><code>AUTHORS = \"Fractal Core Team\"\nDOCS_LINK = \"https://fractal-analytics-platform.github.io/fractal-tasks-core\"\nINPUT_MODELS = [\n    [\"fractal_tasks_core\", \"channels.py\", \"OmeroChannel\"],\n    [\"fractal_tasks_core\", \"channels.py\", \"Window\"],\n    [\"fractal_tasks_core\", \"channels.py\", \"ChannelInputModel\"],\n    [\"fractal_tasks_core\", \"tasks/io_models.py\", \"NapariWorkflowsInput\"],\n    [\"fractal_tasks_core\", \"tasks/io_models.py\", \"NapariWorkflowsOutput\"],\n  ]\n</code></pre></p> </li> <li> <p>In order to create the manifest for your package and write to disk, use <pre><code>fractal-manifest create --package my-fractal-tasks-package\n</code></pre></p> </li> <li> <p>In order to check that the manifest for your package is up to date (e.g. from within the CI), use <pre><code>fractal-manifest check --package my-fractal-tasks-package\n</code></pre></p> </li> </ol>"},{"location":"usage/#run-tasks_1","title":"Run tasks","text":"<p>For each one of your tasks' modules, replace the <code>import</code> from <code>fractal_tasks_core.tasks._utils</code> with <pre><code>from fractal_task_tools.task_wrapper import run_fractal_task\n</code></pre></p>"},{"location":"reference/SUMMARY/","title":"SUMMARY","text":"<ul> <li>fractal_task_tools<ul> <li>_args_schemas</li> <li>_cli</li> <li>_cli_tools</li> <li>_create_manifest</li> <li>_deepdiff</li> <li>_descriptions</li> <li>_package_name_tools</li> <li>_pydantic_generatejsonschema</li> <li>_signature_constraints</li> <li>_task_docs</li> <li>_titles</li> <li>task_models</li> <li>task_wrapper</li> </ul> </li> <li>fractal-manifest<ul> <li>create</li> <li>check</li> </ul> </li> </ul>"},{"location":"reference/fractal-manifest/","title":"fractal-manifest","text":"<p><code>fractal-manifest</code> command-line interface</p> <pre><code>fractal-manifest [-h] {create,check} ...\n</code></pre>"},{"location":"reference/fractal-manifest/check/","title":"check","text":"<p>Check existing manifest file</p> <pre><code>fractal-manifest check [-h] --package PACKAGE  [--task-list-path TASK_LIST_PATH]\n        [--ignore-keys-order IGNORE_KEYS_ORDER]\n</code></pre>"},{"location":"reference/fractal-manifest/check/#named-arguments","title":"Named Arguments","text":"<ul> <li> <p><code>--package</code>: Example: 'fractal_tasks_core'</p> </li> <li> <p><code>--task-list-path</code>: Dot-separated path to the <code>task_list.py</code> module, relative to the package root (default value: 'dev.task_list'). Default: <code>\"dev.task_list\"</code>.</p> </li> <li> <p><code>--ignore-keys-order</code>: Ignore the order of dictionary keys when comparing manifests (default value: False). Default: <code>False</code>.</p> </li> </ul>"},{"location":"reference/fractal-manifest/create/","title":"create","text":"<p>Create new manifest file</p> <pre><code>fractal-manifest create [-h] --package PACKAGE  [--task-list-path\n        TASK_LIST_PATH]\n</code></pre>"},{"location":"reference/fractal-manifest/create/#named-arguments","title":"Named Arguments","text":"<ul> <li> <p><code>--package</code>: Example: 'fractal_tasks_core'</p> </li> <li> <p><code>--task-list-path</code>: Dot-separated path to the <code>task_list.py</code> module, relative to the package root (default value: 'dev.task_list'). Default: <code>\"dev.task_list\"</code>.</p> </li> </ul>"},{"location":"reference/fractal_task_tools/","title":"fractal_task_tools","text":""},{"location":"reference/fractal_task_tools/_args_schemas/","title":"_args_schemas","text":""},{"location":"reference/fractal_task_tools/_args_schemas/#fractal_task_tools._args_schemas._remove_attributes_from_descriptions","title":"<code>_remove_attributes_from_descriptions(old_schema)</code>","text":"<p>Keeps only the description part of the docstrings: e.g from <pre><code>'Custom class for Omero-channel window, based on OME-NGFF v0.4.\\n'\n'\\n'\n'Attributes:\\n'\n'min: Do not change. It will be set to `0` by default.\\n'\n'max: Do not change. It will be set according to bitdepth of the images\\n'\n'    by default (e.g. 65535 for 16 bit images).\\n'\n'start: Lower-bound rescaling value for visualization.\\n'\n'end: Upper-bound rescaling value for visualization.'\n</code></pre> to <code>'Custom class for Omero-channel window, based on OME-NGFF v0.4.\\n'</code>.</p> PARAMETER DESCRIPTION <code>old_schema</code> <p>TBD</p> <p> TYPE: <code>_Schema</code> </p> Source code in <code>src/fractal_task_tools/_args_schemas.py</code> <pre><code>def _remove_attributes_from_descriptions(old_schema: _Schema) -&gt; _Schema:\n\"\"\"\n    Keeps only the description part of the docstrings: e.g from\n    ```\n    'Custom class for Omero-channel window, based on OME-NGFF v0.4.\\\\n'\n    '\\\\n'\n    'Attributes:\\\\n'\n    'min: Do not change. It will be set to `0` by default.\\\\n'\n    'max: Do not change. It will be set according to bitdepth of the images\\\\n'\n    '    by default (e.g. 65535 for 16 bit images).\\\\n'\n    'start: Lower-bound rescaling value for visualization.\\\\n'\n    'end: Upper-bound rescaling value for visualization.'\n    ```\n    to `'Custom class for Omero-channel window, based on OME-NGFF v0.4.\\\\n'`.\n\n    Args:\n        old_schema: TBD\n    \"\"\"\n    new_schema = old_schema.copy()\n    if \"$defs\" in new_schema:\n        for name, definition in new_schema[\"$defs\"].items():\n            if \"description\" in definition.keys():\n                parsed_docstring = docparse(definition[\"description\"])\n                new_schema[\"$defs\"][name][\n                    \"description\"\n                ] = parsed_docstring.short_description\n            elif \"title\" in definition.keys():\n                title = definition[\"title\"]\n                new_schema[\"$defs\"][name][\n                    \"description\"\n                ] = f\"Missing description for {title}.\"\n            else:\n                new_schema[\"$defs\"][name][\n                    \"description\"\n                ] = \"Missing description\"\n    logging.info(\"[_remove_attributes_from_descriptions] END\")\n    return new_schema\n</code></pre>"},{"location":"reference/fractal_task_tools/_args_schemas/#fractal_task_tools._args_schemas.create_schema_for_single_task","title":"<code>create_schema_for_single_task(executable, package=None, pydantic_models=None, task_function=None, verbose=False)</code>","text":"<p>Main function to create a JSON Schema of task arguments</p> <p>This function can be used in two ways:</p> <ol> <li><code>task_function</code> argument is <code>None</code>, <code>package</code> is set, and <code>executable</code>     is a path relative to that package.</li> <li><code>task_function</code> argument is provided, <code>executable</code> is an absolute path     to the function module, and <code>package</code> is `None. This is useful for     testing.</li> </ol> Source code in <code>src/fractal_task_tools/_args_schemas.py</code> <pre><code>def create_schema_for_single_task(\n    executable: str,\n    package: Optional[str] = None,\n    pydantic_models: Optional[list[tuple[str, str, str]]] = None,\n    task_function: Optional[Callable] = None,\n    verbose: bool = False,\n) -&gt; _Schema:\n\"\"\"\n    Main function to create a JSON Schema of task arguments\n\n    This function can be used in two ways:\n\n    1. `task_function` argument is `None`, `package` is set, and `executable`\n        is a path relative to that package.\n    2. `task_function` argument is provided, `executable` is an absolute path\n        to the function module, and `package` is `None. This is useful for\n        testing.\n    \"\"\"\n\n    DEFINITIONS_KEY = \"$defs\"\n\n    logging.info(\"[create_schema_for_single_task] START\")\n    if task_function is None:\n        usage = \"1\"\n        # Usage 1 (standard)\n        if package is None:\n            raise ValueError(\n                \"Cannot call `create_schema_for_single_task with \"\n                f\"{task_function=} and {package=}. Exit.\"\n            )\n        if os.path.isabs(executable):\n            raise ValueError(\n                \"Cannot call `create_schema_for_single_task with \"\n                f\"{task_function=} and absolute {executable=}. Exit.\"\n            )\n    else:\n        usage = \"2\"\n        # Usage 2 (testing)\n        if package is not None:\n            raise ValueError(\n                \"Cannot call `create_schema_for_single_task with \"\n                f\"{task_function=} and non-None {package=}. Exit.\"\n            )\n        if not os.path.isabs(executable):\n            raise ValueError(\n                \"Cannot call `create_schema_for_single_task with \"\n                f\"{task_function=} and non-absolute {executable=}. Exit.\"\n            )\n\n    # Extract function from module\n    if usage == \"1\":\n        # Extract the function name (for the moment we assume the function has\n        # the same name as the module)\n        function_name = Path(executable).with_suffix(\"\").name\n        # Extract the function object\n        task_function = _extract_function(\n            package_name=package,\n            module_relative_path=executable,\n            function_name=function_name,\n            verbose=verbose,\n        )\n    else:\n        # The function object is already available, extract its name\n        function_name = task_function.__name__\n\n    if verbose:\n        logging.info(f\"[create_schema_for_single_task] {function_name=}\")\n        logging.info(f\"[create_schema_for_single_task] {task_function=}\")\n\n    # Validate function signature against some custom constraints\n    _validate_function_signature(task_function)\n\n    # Create and clean up schema\n    schema = _create_schema_for_function(task_function)\n    schema = _remove_attributes_from_descriptions(schema)\n\n    # Include titles for custom-model-typed arguments\n    schema = _include_titles(\n        schema, definitions_key=DEFINITIONS_KEY, verbose=verbose\n    )\n\n    # Include main title\n    if schema.get(\"title\") is None:\n\n        def to_camel_case(snake_str):\n            return \"\".join(\n                x.capitalize() for x in snake_str.lower().split(\"_\")\n            )\n\n        schema[\"title\"] = to_camel_case(task_function.__name__)\n\n    # Include descriptions of function. Note: this function works both\n    # for usages 1 or 2 (see docstring).\n    function_args_descriptions = _get_function_args_descriptions(\n        package_name=package,\n        module_path=executable,\n        function_name=function_name,\n        verbose=verbose,\n    )\n\n    schema = _insert_function_args_descriptions(\n        schema=schema, descriptions=function_args_descriptions\n    )\n\n    if pydantic_models is not None:\n        # Check that model names are unique\n        pydantic_models_names = [item[2] for item in pydantic_models]\n        duplicate_class_names = [\n            name\n            for name, count in Counter(pydantic_models_names).items()\n            if count &gt; 1\n        ]\n        if duplicate_class_names:\n            pydantic_models_str = \"  \" + \"\\n  \".join(map(str, pydantic_models))\n            raise ValueError(\n                \"Cannot parse docstrings for models with non-unique names \"\n                f\"{duplicate_class_names}, in\\n{pydantic_models_str}\"\n            )\n\n        # Extract model-attribute descriptions and insert them into schema\n        for package_name, module_relative_path, class_name in pydantic_models:\n            attrs_descriptions = _get_class_attrs_descriptions(\n                package_name=package_name,\n                module_relative_path=module_relative_path,\n                class_name=class_name,\n            )\n            schema = _insert_class_attrs_descriptions(\n                schema=schema,\n                class_name=class_name,\n                descriptions=attrs_descriptions,\n                definition_key=DEFINITIONS_KEY,\n            )\n\n    logging.info(\"[create_schema_for_single_task] END\")\n    return schema\n</code></pre>"},{"location":"reference/fractal_task_tools/_cli/","title":"_cli","text":""},{"location":"reference/fractal_task_tools/_cli/#fractal_task_tools._cli._parse_arguments","title":"<code>_parse_arguments(sys_argv=None)</code>","text":"<p>Parse <code>sys.argv</code> or custom CLI arguments.</p> PARAMETER DESCRIPTION <code>sys_argv</code> <p>If set, overrides <code>sys.argv</code> (useful for testing).</p> <p> TYPE: <code>list[str] | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/fractal_task_tools/_cli.py</code> <pre><code>def _parse_arguments(sys_argv: list[str] | None = None) -&gt; ap.Namespace:\n\"\"\"\n    Parse `sys.argv` or custom CLI arguments.\n\n    Arguments:\n        sys_argv: If set, overrides `sys.argv` (useful for testing).\n    \"\"\"\n    if sys_argv is None:\n        sys_argv = sys.argv[:]\n    args = main_parser.parse_args(sys_argv[1:])\n    return args\n</code></pre>"},{"location":"reference/fractal_task_tools/_cli_tools/","title":"_cli_tools","text":""},{"location":"reference/fractal_task_tools/_cli_tools/#fractal_task_tools._cli_tools.check_manifest","title":"<code>check_manifest(*, raw_package_name, manifest, ignore_keys_order)</code>","text":"<p>Write manifest to file.</p> PARAMETER DESCRIPTION <code>raw_package_name</code> <p> TYPE: <code>str</code> </p> <code>manifest</code> <p>The manifest object</p> <p> TYPE: <code>str</code> </p> <code>ignore_keys_order</code> <p>Whether to ignore keys order.</p> <p> TYPE: <code>bool</code> </p> Source code in <code>src/fractal_task_tools/_cli_tools.py</code> <pre><code>def check_manifest(\n    *,\n    raw_package_name: str,\n    manifest: str,\n    ignore_keys_order: bool,\n) -&gt; None:\n\"\"\"\n    Write manifest to file.\n\n    Arguments:\n        raw_package_name:\n        manifest: The manifest object\n        ignore_keys_order: Whether to ignore keys order.\n    \"\"\"\n\n    package_name = normalize_package_name(raw_package_name)\n    logging.info(f\"[check_manifest] {package_name=}\")\n\n    imported_package = import_module(package_name)\n    package_root_dir = Path(imported_package.__file__).parent\n    manifest_path = (package_root_dir / MANIFEST_FILENAME).as_posix()\n    logging.info(f\"[check_manifest] {os.getcwd()=}\")\n    logging.info(f\"[check_manifest] {package_root_dir=}\")\n    logging.info(f\"[check_manifest] {manifest_path=}\")\n\n    with open(manifest_path, \"r\") as f:\n        old_manifest = json.load(f)\n    if manifest == old_manifest:\n        logging.info(\"[check_manifest] On-disk manifest is up to date.\")\n    else:\n        logging.error(\"[check_manifest] On-disk manifest is not up to date.\")\n        try:\n            deepdiff(\n                old_object=old_manifest,\n                new_object=manifest,\n                path=\"manifest\",\n                ignore_keys_order=ignore_keys_order,\n            )\n        except ValueError as e:\n            logging.error(str(e))\n            sys.exit(\"New/old manifests differ\")\n\n    logging.info(\"[check_manifest] END\")\n</code></pre>"},{"location":"reference/fractal_task_tools/_cli_tools/#fractal_task_tools._cli_tools.write_manifest_to_file","title":"<code>write_manifest_to_file(*, raw_package_name, manifest)</code>","text":"<p>Write manifest to file.</p> PARAMETER DESCRIPTION <code>raw_package_name</code> <p> TYPE: <code>str</code> </p> <code>manifest</code> <p>The manifest object</p> <p> TYPE: <code>str</code> </p> Source code in <code>src/fractal_task_tools/_cli_tools.py</code> <pre><code>def write_manifest_to_file(\n    *,\n    raw_package_name: str,\n    manifest: str,\n) -&gt; None:\n\"\"\"\n    Write manifest to file.\n\n    Arguments:\n        raw_package_name:\n        manifest: The manifest object\n    \"\"\"\n    logging.info(\"[write_manifest_to_file] START\")\n\n    package_name = normalize_package_name(raw_package_name)\n    logging.info(f\"[write_manifest_to_file] {package_name=}\")\n\n    imported_package = import_module(package_name)\n    package_root_dir = Path(imported_package.__file__).parent\n    manifest_path = (package_root_dir / MANIFEST_FILENAME).as_posix()\n    logging.info(f\"[write_manifest_to_file] {os.getcwd()=}\")\n    logging.info(f\"[write_manifest_to_file] {package_root_dir=}\")\n    logging.info(f\"[write_manifest_to_file] {manifest_path=}\")\n\n    with open(manifest_path, \"w\") as f:\n        json.dump(manifest, f, indent=2)\n        f.write(\"\\n\")\n\n    logging.info(\"[write_manifest_to_file] END\")\n</code></pre>"},{"location":"reference/fractal_task_tools/_create_manifest/","title":"_create_manifest","text":"<p>Generate JSON schemas for task arguments and combine them into a manifest.</p>"},{"location":"reference/fractal_task_tools/_create_manifest/#fractal_task_tools._create_manifest.create_manifest","title":"<code>create_manifest(*, raw_package_name, task_list_path)</code>","text":"<p>Create the package manifest based on a <code>task_list.py</code> module</p> PARAMETER DESCRIPTION <code>raw_package_name</code> <p>The name of the package. Note that this name must be importable (after normalization).</p> <p> TYPE: <code>str</code> </p> <code>task_list_path</code> <p>Relative path to the <code>task_list.py</code> module, with respect to the package root (example <code>dev.task_list</code>).</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>dict[str, Any]</code> <p>Task-package manifest.</p> Source code in <code>src/fractal_task_tools/_create_manifest.py</code> <pre><code>def create_manifest(\n    *,\n    raw_package_name: str,\n    task_list_path: str,\n) -&gt; dict[str, Any]:\n\"\"\"\n    Create the package manifest based on a `task_list.py` module\n\n    Arguments:\n        raw_package_name:\n            The name of the package. Note that this name must be importable\n            (after normalization).\n        task_list_path:\n            Relative path to the `task_list.py` module, with respect to the\n            package root (example `dev.task_list`).\n\n    Returns:\n        Task-package manifest.\n    \"\"\"\n\n    # Preliminary validation\n    if \"/\" in task_list_path or task_list_path.endswith(\".py\"):\n        raise ValueError(\n            f\"Invalid {task_list_path=} (valid example: `dev.task_list`).\"\n        )\n\n    # Normalize package name\n    package_name = normalize_package_name(raw_package_name)\n\n    logging.info(f\"Start generating a new manifest for {package_name}\")\n\n    # Prepare an empty manifest\n    manifest = dict(\n        manifest_version=MANIFEST_VERSION,\n        task_list=[],\n        has_args_schemas=True,\n        args_schema_version=ARGS_SCHEMA_VERSION,\n        authors=None,\n    )\n\n    # Import the task-list module\n    task_list_module = import_module(f\"{package_name}.{task_list_path}\")\n\n    # Load TASK_LIST\n    TASK_LIST = getattr(task_list_module, \"TASK_LIST\")\n\n    # Load INPUT_MODELS\n    try:\n        INPUT_MODELS = getattr(task_list_module, \"INPUT_MODELS\")\n    except AttributeError:\n        INPUT_MODELS = []\n        logging.warning(\n            \"No `INPUT_MODELS` found in task_list module. Setting it to `[]`.\"\n        )\n\n    # Load AUTHORS\n    try:\n        manifest[\"authors\"] = getattr(task_list_module, \"AUTHORS\")\n    except AttributeError:\n        logging.warning(\"No `AUTHORS` found in task_list module.\")\n\n    # Load DOCS_LINK\n    try:\n        DOCS_LINK = getattr(task_list_module, \"DOCS_LINK\")\n    except AttributeError:\n        DOCS_LINK = None\n        logging.warning(\"No `DOCS_LINK` found in task_list module.\")\n\n    # Loop over TASK_LIST, and append the proper task dictionaries\n    # to manifest[\"task_list\"]\n    for task_obj in TASK_LIST:\n        # Convert Pydantic object to dictionary\n        task_dict = task_obj.model_dump(\n            exclude={\"meta_init\", \"executable_init\", \"meta\", \"executable\"},\n            exclude_unset=True,\n        )\n\n        # Copy some properties from `task_obj` to `task_dict`\n        if task_obj.executable_non_parallel is not None:\n            task_dict[\n                \"executable_non_parallel\"\n            ] = task_obj.executable_non_parallel\n        if task_obj.executable_parallel is not None:\n            task_dict[\"executable_parallel\"] = task_obj.executable_parallel\n        if task_obj.meta_non_parallel is not None:\n            task_dict[\"meta_non_parallel\"] = task_obj.meta_non_parallel\n        if task_obj.meta_parallel is not None:\n            task_dict[\"meta_parallel\"] = task_obj.meta_parallel\n\n        # Autogenerate JSON Schemas for non-parallel/parallel task arguments\n        for kind in [\"non_parallel\", \"parallel\"]:\n            executable = task_dict.get(f\"executable_{kind}\")\n            if executable is not None:\n                logging.info(f\"[{executable}] START\")\n                schema = create_schema_for_single_task(\n                    executable,\n                    package=package_name,\n                    pydantic_models=INPUT_MODELS,\n                )\n                logging.info(f\"[{executable}] END (new schema)\")\n                task_dict[f\"args_schema_{kind}\"] = schema\n\n        # Compute and set `docs_info`\n        docs_info = task_dict.get(\"docs_info\")\n        if docs_info is None:\n            docs_info = create_docs_info(\n                executable_non_parallel=task_obj.executable_non_parallel,\n                executable_parallel=task_obj.executable_parallel,\n                package=package_name,\n            )\n        elif docs_info.startswith(\"file:\"):\n            docs_info = read_docs_info_from_file(\n                docs_info=docs_info,\n                task_list_path=task_list_module.__file__,\n            )\n        if docs_info is not None:\n            task_dict[\"docs_info\"] = docs_info\n\n        # Set `docs_link`\n        if DOCS_LINK is not None:\n            task_dict[\"docs_link\"] = DOCS_LINK\n\n        # Append task\n        manifest[\"task_list\"].append(task_dict)\n    return manifest\n</code></pre>"},{"location":"reference/fractal_task_tools/_deepdiff/","title":"_deepdiff","text":""},{"location":"reference/fractal_task_tools/_descriptions/","title":"_descriptions","text":""},{"location":"reference/fractal_task_tools/_descriptions/#fractal_task_tools._descriptions._get_class_attrs_descriptions","title":"<code>_get_class_attrs_descriptions(package_name, module_relative_path, class_name)</code>","text":"<p>Extract attribute descriptions from a class.</p> PARAMETER DESCRIPTION <code>package_name</code> <p>Example <code>fractal_tasks_core</code>.</p> <p> TYPE: <code>str</code> </p> <code>module_relative_path</code> <p>Example <code>lib_channels.py</code>.</p> <p> TYPE: <code>str</code> </p> <code>class_name</code> <p>Example <code>OmeroChannel</code>.</p> <p> TYPE: <code>str</code> </p> Source code in <code>src/fractal_task_tools/_descriptions.py</code> <pre><code>def _get_class_attrs_descriptions(\n    package_name: str, module_relative_path: str, class_name: str\n) -&gt; dict[str, str]:\n\"\"\"\n    Extract attribute descriptions from a class.\n\n    Args:\n        package_name: Example `fractal_tasks_core`.\n        module_relative_path: Example `lib_channels.py`.\n        class_name: Example `OmeroChannel`.\n    \"\"\"\n\n    if not module_relative_path.endswith(\".py\"):\n        raise ValueError(f\"Module {module_relative_path} must end with '.py'\")\n\n    # Get the class ast.ClassDef object\n    package_path = Path(import_module(package_name).__file__).parent\n    module_path = package_path / module_relative_path\n    tree = ast.parse(module_path.read_text())\n    try:\n        _class = next(\n            c\n            for c in ast.walk(tree)\n            if (isinstance(c, ast.ClassDef) and c.name == class_name)\n        )\n    except StopIteration:\n        raise RuntimeError(\n            f\"Cannot find {class_name=} for {package_name=} \"\n            f\"and {module_relative_path=}\"\n        )\n    docstring = ast.get_docstring(_class)\n    parsed_docstring = docparse(docstring)\n    descriptions = {\n        x.arg_name: _sanitize_description(x.description)\n        if x.description\n        else \"Missing description\"\n        for x in parsed_docstring.params\n    }\n    logging.info(f\"[_get_class_attrs_descriptions] END ({class_name=})\")\n    return descriptions\n</code></pre>"},{"location":"reference/fractal_task_tools/_descriptions/#fractal_task_tools._descriptions._get_function_args_descriptions","title":"<code>_get_function_args_descriptions(*, package_name, module_path, function_name, verbose=False)</code>","text":"<p>Extract argument descriptions from a function.</p> PARAMETER DESCRIPTION <code>package_name</code> <p>Example <code>fractal_tasks_core</code>.</p> <p> TYPE: <code>Optional[str]</code> </p> <code>module_path</code> <p>This must be an absolute path like <code>/some/module.py</code> (if <code>package_name</code> is <code>None</code>) or a relative path like <code>something.py</code> (if <code>package_name</code> is not <code>None</code>).</p> <p> TYPE: <code>str</code> </p> <code>function_name</code> <p>Example <code>create_ome_zarr</code>.</p> <p> TYPE: <code>str</code> </p> Source code in <code>src/fractal_task_tools/_descriptions.py</code> <pre><code>def _get_function_args_descriptions(\n    *,\n    package_name: Optional[str],\n    module_path: str,\n    function_name: str,\n    verbose: bool = False,\n) -&gt; dict[str, str]:\n\"\"\"\n    Extract argument descriptions from a function.\n\n    Args:\n        package_name: Example `fractal_tasks_core`.\n        module_path:\n            This must be an absolute path like `/some/module.py` (if\n            `package_name` is `None`) or a relative path like `something.py`\n            (if `package_name` is not `None`).\n        function_name: Example `create_ome_zarr`.\n    \"\"\"\n\n    # Extract docstring from ast.FunctionDef\n    docstring = _get_function_docstring(\n        package_name=package_name,\n        module_path=module_path,\n        function_name=function_name,\n        verbose=verbose,\n    )\n    if verbose:\n        logging.info(f\"[_get_function_args_descriptions] {docstring}\")\n\n    # Parse docstring (via docstring_parser) and prepare output\n    parsed_docstring = docparse(docstring)\n    descriptions = {\n        param.arg_name: _sanitize_description(param.description)\n        for param in parsed_docstring.params\n    }\n    logging.info(f\"[_get_function_args_descriptions] END ({function_name=})\")\n    return descriptions\n</code></pre>"},{"location":"reference/fractal_task_tools/_descriptions/#fractal_task_tools._descriptions._get_function_docstring","title":"<code>_get_function_docstring(*, package_name, module_path, function_name, verbose=False)</code>","text":"<p>Extract docstring from a function.</p> PARAMETER DESCRIPTION <code>package_name</code> <p>Example <code>fractal_tasks_core</code>.</p> <p> TYPE: <code>Optional[str]</code> </p> <code>module_path</code> <p>This must be an absolute path like <code>/some/module.py</code> (if <code>package_name</code> is <code>None</code>) or a relative path like <code>something.py</code> (if <code>package_name</code> is not <code>None</code>).</p> <p> TYPE: <code>str</code> </p> <code>function_name</code> <p>Example <code>create_ome_zarr</code>.</p> <p> TYPE: <code>str</code> </p> Source code in <code>src/fractal_task_tools/_descriptions.py</code> <pre><code>def _get_function_docstring(\n    *,\n    package_name: Optional[str],\n    module_path: str,\n    function_name: str,\n    verbose: bool = False,\n) -&gt; str:\n\"\"\"\n    Extract docstring from a function.\n\n\n    Args:\n        package_name: Example `fractal_tasks_core`.\n        module_path:\n            This must be an absolute path like `/some/module.py` (if\n            `package_name` is `None`) or a relative path like `something.py`\n            (if `package_name` is not `None`).\n        function_name: Example `create_ome_zarr`.\n    \"\"\"\n\n    if not module_path.endswith(\".py\"):\n        raise ValueError(f\"Module {module_path} must end with '.py'\")\n\n    # Get the function ast.FunctionDef object\n    if package_name is not None:\n        if os.path.isabs(module_path):\n            raise ValueError(\n                \"Error in _get_function_docstring: `package_name` is not \"\n                \"None but `module_path` is absolute.\"\n            )\n        package_path = Path(import_module(package_name).__file__).parent\n        module_path = package_path / module_path\n    else:\n        if not os.path.isabs(module_path):\n            raise ValueError(\n                \"Error in _get_function_docstring: `package_name` is None \"\n                \"but `module_path` is not absolute.\"\n            )\n        module_path = Path(module_path)\n\n    if verbose:\n        logging.info(f\"[_get_function_docstring] {function_name=}\")\n        logging.info(f\"[_get_function_docstring] {module_path=}\")\n\n    tree = ast.parse(module_path.read_text())\n    _function = next(\n        f\n        for f in ast.walk(tree)\n        if (isinstance(f, ast.FunctionDef) and f.name == function_name)\n    )\n\n    # Extract docstring from ast.FunctionDef\n    return ast.get_docstring(_function)\n</code></pre>"},{"location":"reference/fractal_task_tools/_descriptions/#fractal_task_tools._descriptions._insert_class_attrs_descriptions","title":"<code>_insert_class_attrs_descriptions(*, schema, class_name, descriptions, definition_key)</code>","text":"<p>Merge the descriptions obtained via <code>_get_attributes_models_descriptions</code> into the <code>class_name</code> definition, within an existing JSON Schema</p> PARAMETER DESCRIPTION <code>schema</code> <p>TBD</p> <p> TYPE: <code>dict</code> </p> <code>class_name</code> <p>TBD</p> <p> TYPE: <code>str</code> </p> <code>descriptions</code> <p>TBD</p> <p> TYPE: <code>dict</code> </p> <code>definition_key</code> <p>Either <code>\"definitions\"</code> (for Pydantic V1) or <code>\"$defs\"</code> (for Pydantic V2)</p> <p> TYPE: <code>str</code> </p> Source code in <code>src/fractal_task_tools/_descriptions.py</code> <pre><code>def _insert_class_attrs_descriptions(\n    *,\n    schema: dict,\n    class_name: str,\n    descriptions: dict,\n    definition_key: str,\n):\n\"\"\"\n    Merge the descriptions obtained via `_get_attributes_models_descriptions`\n    into the `class_name` definition, within an existing JSON Schema\n\n    Args:\n        schema: TBD\n        class_name: TBD\n        descriptions: TBD\n        definition_key: Either `\"definitions\"` (for Pydantic V1) or\n            `\"$defs\"` (for Pydantic V2)\n    \"\"\"\n    new_schema = schema.copy()\n    if definition_key not in schema:\n        return new_schema\n    else:\n        new_definitions = schema[definition_key].copy()\n    # Loop over existing definitions\n    for name, definition in schema[definition_key].items():\n        if name == class_name:\n            for prop in definition[\"properties\"]:\n                if \"description\" in new_definitions[name][\"properties\"][prop]:\n                    raise ValueError(\n                        f\"Property {name}.{prop} already has description\"\n                    )\n                else:\n                    new_definitions[name][\"properties\"][prop][\n                        \"description\"\n                    ] = descriptions[prop]\n    new_schema[definition_key] = new_definitions\n    logging.info(\"[_insert_class_attrs_descriptions] END\")\n    return new_schema\n</code></pre>"},{"location":"reference/fractal_task_tools/_descriptions/#fractal_task_tools._descriptions._insert_function_args_descriptions","title":"<code>_insert_function_args_descriptions(*, schema, descriptions, verbose=False)</code>","text":"<p>Merge the descriptions obtained via <code>_get_args_descriptions</code> into the properties of an existing JSON Schema.</p> PARAMETER DESCRIPTION <code>schema</code> <p>TBD</p> <p> TYPE: <code>dict</code> </p> <code>descriptions</code> <p>TBD</p> <p> TYPE: <code>dict</code> </p> Source code in <code>src/fractal_task_tools/_descriptions.py</code> <pre><code>def _insert_function_args_descriptions(\n    *, schema: dict, descriptions: dict, verbose: bool = False\n):\n\"\"\"\n    Merge the descriptions obtained via `_get_args_descriptions` into the\n    properties of an existing JSON Schema.\n\n    Args:\n        schema: TBD\n        descriptions: TBD\n    \"\"\"\n    new_schema = schema.copy()\n    new_properties = schema[\"properties\"].copy()\n    for key, value in schema[\"properties\"].items():\n        if \"description\" in value:\n            raise ValueError(\"Property already has description\")\n        else:\n            if key in descriptions:\n                value[\"description\"] = descriptions[key]\n            else:\n                value[\"description\"] = \"Missing description\"\n            new_properties[key] = value\n            if verbose:\n                logging.info(\n                    \"[_insert_function_args_descriptions] \"\n                    f\"Add {key=}, {value=}\"\n                )\n    new_schema[\"properties\"] = new_properties\n    logging.info(\"[_insert_function_args_descriptions] END\")\n    return new_schema\n</code></pre>"},{"location":"reference/fractal_task_tools/_descriptions/#fractal_task_tools._descriptions._sanitize_description","title":"<code>_sanitize_description(string)</code>","text":"<p>Sanitize a description string.</p> <p>This is a provisional helper function that replaces newlines with spaces and reduces multiple contiguous whitespace characters to a single one. Future iterations of the docstrings format/parsing may render this function not-needed or obsolete.</p> PARAMETER DESCRIPTION <code>string</code> <p>TBD</p> <p> TYPE: <code>str</code> </p> Source code in <code>src/fractal_task_tools/_descriptions.py</code> <pre><code>def _sanitize_description(string: str) -&gt; str:\n\"\"\"\n    Sanitize a description string.\n\n    This is a provisional helper function that replaces newlines with spaces\n    and reduces multiple contiguous whitespace characters to a single one.\n    Future iterations of the docstrings format/parsing may render this function\n    not-needed or obsolete.\n\n    Args:\n        string: TBD\n    \"\"\"\n    # Replace newline with space\n    new_string = string.replace(\"\\n\", \" \")\n    # Replace N-whitespace characters with a single one\n    while \"  \" in new_string:\n        new_string = new_string.replace(\"  \", \" \")\n    return new_string\n</code></pre>"},{"location":"reference/fractal_task_tools/_package_name_tools/","title":"_package_name_tools","text":""},{"location":"reference/fractal_task_tools/_package_name_tools/#fractal_task_tools._package_name_tools.normalize_package_name","title":"<code>normalize_package_name(pkg_name)</code>","text":"<p>Implement both PyPa and custom package-name normalization</p> <ol> <li>PyPa normalization: The name should be lowercased with all runs of the     characters <code>.</code>, <code>-</code>, or <code>_</code> replaced with a single <code>-</code> character     (https://packaging.python.org/en/latest/specifications/name-normalization).</li> <li>Custom normalization: Replace <code>-</code> with <code>_</code>, to obtain the     imported-module name.</li> </ol> PARAMETER DESCRIPTION <code>pkg_name</code> <p>The non-normalized package name.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>str</code> <p>The normalized package name.</p> Source code in <code>src/fractal_task_tools/_package_name_tools.py</code> <pre><code>def normalize_package_name(pkg_name: str) -&gt; str:\n\"\"\"\n    Implement both PyPa and custom package-name normalization\n\n    1. PyPa normalization: The name should be lowercased with all runs of the\n        characters `.`, `-`, or `_` replaced with a single `-` character\n        (https://packaging.python.org/en/latest/specifications/name-normalization).\n    2. Custom normalization: Replace `-` with `_`, to obtain the\n        imported-module name.\n\n    Args:\n        pkg_name: The non-normalized package name.\n\n    Returns:\n        The normalized package name.\n    \"\"\"\n\n    # Apply PyPa normalization\n    pypa_normalized_package_name = re.sub(r\"[-_.]+\", \"-\", pkg_name).lower()\n\n    # Replace `-` with `_`\n    final_package_name = pypa_normalized_package_name.replace(\"-\", \"_\")\n\n    return final_package_name\n</code></pre>"},{"location":"reference/fractal_task_tools/_pydantic_generatejsonschema/","title":"_pydantic_generatejsonschema","text":"<p>Custom Pydantic v2 JSON Schema generation tools.</p> <p>As of Pydantic V2, the JSON Schema representation of model attributes marked as <code>Optional</code> changed, and the new behavior consists in marking the corresponding properties as an <code>anyOf</code> of either a <code>null</code> or the actual type. This is not always the required behavior, see e.g. * https://github.com/pydantic/pydantic/issues/7161 * https://github.com/pydantic/pydantic/issues/8394</p> <p>Here we list some alternative ways of reverting this change.</p>"},{"location":"reference/fractal_task_tools/_signature_constraints/","title":"_signature_constraints","text":""},{"location":"reference/fractal_task_tools/_signature_constraints/#fractal_task_tools._signature_constraints._extract_function","title":"<code>_extract_function(module_relative_path, function_name, package_name, verbose=False)</code>","text":"<p>Extract function from a module with the same name.</p> PARAMETER DESCRIPTION <code>package_name</code> <p>Example <code>fractal_tasks_core</code>.</p> <p> TYPE: <code>str</code> </p> <code>module_relative_path</code> <p>Example <code>tasks/create_ome_zarr.py</code>.</p> <p> TYPE: <code>str</code> </p> <code>function_name</code> <p>Example <code>create_ome_zarr</code>.</p> <p> TYPE: <code>str</code> </p> <code>verbose</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> Source code in <code>src/fractal_task_tools/_signature_constraints.py</code> <pre><code>def _extract_function(\n    module_relative_path: str,\n    function_name: str,\n    package_name: str,\n    verbose: bool = False,\n) -&gt; callable:\n\"\"\"\n    Extract function from a module with the same name.\n\n    Args:\n        package_name: Example `fractal_tasks_core`.\n        module_relative_path: Example `tasks/create_ome_zarr.py`.\n        function_name: Example `create_ome_zarr`.\n        verbose:\n    \"\"\"\n    if not module_relative_path.endswith(\".py\"):\n        raise ValueError(f\"{module_relative_path=} must end with '.py'\")\n    module_relative_path_no_py = str(\n        Path(module_relative_path).with_suffix(\"\")\n    )\n    module_relative_path_dots = module_relative_path_no_py.replace(\"/\", \".\")\n    if verbose:\n        logging.info(\n            f\"Now calling `import_module` for \"\n            f\"{package_name}.{module_relative_path_dots}\"\n        )\n    imported_module = import_module(\n        f\"{package_name}.{module_relative_path_dots}\"\n    )\n    if verbose:\n        logging.info(\n            f\"Now getting attribute {function_name} from \"\n            f\"imported module {imported_module}.\"\n        )\n    task_function = getattr(imported_module, function_name)\n    return task_function\n</code></pre>"},{"location":"reference/fractal_task_tools/_signature_constraints/#fractal_task_tools._signature_constraints._validate_function_signature","title":"<code>_validate_function_signature(function)</code>","text":"<p>Validate the function signature.</p> <p>Implement a set of checks for type hints that do not play well with the creation of JSON Schema, see https://github.com/fractal-analytics-platform/fractal-tasks-core/issues/399.</p> PARAMETER DESCRIPTION <code>function</code> <p>TBD</p> <p> TYPE: <code>callable</code> </p> Source code in <code>src/fractal_task_tools/_signature_constraints.py</code> <pre><code>def _validate_function_signature(function: callable):\n\"\"\"\n    Validate the function signature.\n\n    Implement a set of checks for type hints that do not play well with the\n    creation of JSON Schema, see\n    https://github.com/fractal-analytics-platform/fractal-tasks-core/issues/399.\n\n    Args:\n        function: TBD\n    \"\"\"\n    sig = signature(function)\n    for param in sig.parameters.values():\n\n        # CASE 1: Check that name is not forbidden\n        if param.name in FORBIDDEN_PARAM_NAMES:\n            raise ValueError(\n                f\"Function {function} has argument with name {param.name}\"\n            )\n\n        # CASE 2: Raise an error for unions\n        if str(param.annotation).startswith((\"typing.Union[\", \"Union[\")):\n            raise ValueError(\"typing.Union is not supported\")\n\n        # CASE 3: Raise an error for \"|\"\n        if \"|\" in str(param.annotation):\n            raise ValueError('Use of \"|\" in type hints is not supported')\n\n        # CASE 4: Raise an error for optional parameter with given (non-None)\n        # default, e.g. Optional[str] = \"asd\"\n        is_annotation_optional = str(param.annotation).startswith(\n            (\"typing.Optional[\", \"Optional[\")\n        )\n        default_given = (param.default is not None) and (\n            param.default != inspect._empty\n        )\n        if default_given and is_annotation_optional:\n            raise ValueError(\"Optional parameter has non-None default value\")\n\n    logging.info(\"[_validate_function_signature] END\")\n    return sig\n</code></pre>"},{"location":"reference/fractal_task_tools/_task_docs/","title":"_task_docs","text":""},{"location":"reference/fractal_task_tools/_task_docs/#fractal_task_tools._task_docs._get_function_description","title":"<code>_get_function_description(package_name, module_path, function_name)</code>","text":"<p>Extract function description from its docstring.</p> PARAMETER DESCRIPTION <code>package_name</code> <p>Example <code>fractal_tasks_core</code>.</p> <p> TYPE: <code>str</code> </p> <code>module_path</code> <p>Example <code>tasks/create_ome_zarr.py</code>.</p> <p> TYPE: <code>str</code> </p> <code>function_name</code> <p>Example <code>create_ome_zarr</code>.</p> <p> TYPE: <code>str</code> </p> Source code in <code>src/fractal_task_tools/_task_docs.py</code> <pre><code>def _get_function_description(\n    package_name: str, module_path: str, function_name: str\n) -&gt; str:\n\"\"\"\n    Extract function description from its docstring.\n\n    Args:\n        package_name: Example `fractal_tasks_core`.\n        module_path: Example `tasks/create_ome_zarr.py`.\n        function_name: Example `create_ome_zarr`.\n    \"\"\"\n    # Extract docstring from ast.FunctionDef\n    docstring = _get_function_docstring(\n        package_name=package_name,\n        module_path=module_path,\n        function_name=function_name,\n    )\n    # Parse docstring (via docstring_parser)\n    parsed_docstring = docparse(docstring)\n    # Combine short/long descriptions (if present)\n    short_description = parsed_docstring.short_description\n    long_description = parsed_docstring.long_description\n    items = []\n    if short_description:\n        items.append(short_description)\n    if long_description:\n        items.append(long_description)\n    if items:\n        if parsed_docstring.blank_after_short_description:\n            return \"\\n\\n\".join(items)\n        else:\n            return \"\\n\".join(items)\n    else:\n        return \"\"\n</code></pre>"},{"location":"reference/fractal_task_tools/_task_docs/#fractal_task_tools._task_docs.create_docs_info","title":"<code>create_docs_info(*, executable_non_parallel=None, executable_parallel=None, package)</code>","text":"<p>Return task description based on function docstring.</p> Source code in <code>src/fractal_task_tools/_task_docs.py</code> <pre><code>def create_docs_info(\n    *,\n    executable_non_parallel: Optional[str] = None,\n    executable_parallel: Optional[str] = None,\n    package: str,\n) -&gt; str:\n\"\"\"\n    Return task description based on function docstring.\n    \"\"\"\n    logging.info(\"[create_docs_info] START\")\n    docs_info = []\n    for executable in [executable_non_parallel, executable_parallel]:\n        if executable is None:\n            continue\n        # Extract the function name.\n        # Note: this could be made more general, but for the moment we assume\n        # that the function has the same name as the module)\n        function_name = Path(executable).with_suffix(\"\").name\n        logging.info(f\"[create_docs_info] {function_name=}\")\n        # Get function description\n        description = _get_function_description(\n            package_name=package,\n            module_path=executable,\n            function_name=function_name,\n        )\n        docs_info.append(f\"## {function_name}\\n{description}\\n\")\n    docs_info = \"\".join(docs_info)\n    logging.info(\"[create_docs_info] END\")\n    return docs_info\n</code></pre>"},{"location":"reference/fractal_task_tools/_task_docs/#fractal_task_tools._task_docs.read_docs_info_from_file","title":"<code>read_docs_info_from_file(*, docs_info, task_list_path)</code>","text":"<p>Return task description based on the content of a file.</p> <p>An example of valid argument is <pre><code>docs_info = \"file:relative/path/info.md\"\n</code></pre> where the path is relative to the folder where <code>task_list.py</code> is.</p> Source code in <code>src/fractal_task_tools/_task_docs.py</code> <pre><code>def read_docs_info_from_file(\n    *,\n    docs_info: str,\n    task_list_path: str,\n) -&gt; str:\n\"\"\"\n    Return task description based on the content of a file.\n\n    An example of valid argument is\n    ```\n    docs_info = \"file:relative/path/info.md\"\n    ```\n    where the path is relative to the folder where `task_list.py` is.\n    \"\"\"\n    logging.info(\"[read_docs_info_from_file] START\")\n\n    # Preliminary checks\n    if not docs_info.startswith(\"file:\"):\n        raise ValueError(f\"Invalid docs_info='{docs_info}'.\")\n    relative_path = Path(docs_info[5:])\n    if relative_path.is_absolute():\n        raise ValueError(\n            f\"Invalid docs_info='{docs_info}' (path must be relative).\"\n        )\n\n    base_path = Path(task_list_path).parent\n    docs_path = (base_path / relative_path).as_posix()\n    logging.info(f\"[read_docs_info_from_file] Reading docs from {docs_path}\")\n    with open(docs_path, \"r\") as f:\n        docs_info = f.read()\n    logging.info(\"[read_docs_info_from_file] END\")\n\n    return docs_info\n</code></pre>"},{"location":"reference/fractal_task_tools/_titles/","title":"_titles","text":""},{"location":"reference/fractal_task_tools/_titles/#fractal_task_tools._titles._include_titles","title":"<code>_include_titles(schema, definitions_key, verbose=False)</code>","text":"<p>Include property titles, when missing.</p> <p>This handles both:</p> <ul> <li>first-level JSON Schema properties (corresponding to task     arguments);</li> <li>properties of JSON Schema definitions (corresponding to     task-argument attributes).</li> </ul> PARAMETER DESCRIPTION <code>schema</code> <p>TBD</p> <p> TYPE: <code>_Schema</code> </p> <code>definitions_key</code> <p>Either <code>\"definitions\"</code> (for Pydantic V1) or <code>\"$defs\"</code> (for Pydantic V2)</p> <p> TYPE: <code>str</code> </p> <code>verbose</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> Source code in <code>src/fractal_task_tools/_titles.py</code> <pre><code>def _include_titles(\n    schema: _Schema,\n    definitions_key: str,\n    verbose: bool = False,\n) -&gt; _Schema:\n\"\"\"\n    Include property titles, when missing.\n\n    This handles both:\n\n    - first-level JSON Schema properties (corresponding to task\n        arguments);\n    - properties of JSON Schema definitions (corresponding to\n        task-argument attributes).\n\n    Args:\n        schema: TBD\n        definitions_key: Either `\"definitions\"` (for Pydantic V1) or\n            `\"$defs\"` (for Pydantic V2)\n        verbose:\n    \"\"\"\n    new_schema = schema.copy()\n\n    if verbose:\n        logging.info(\"[_include_titles] START\")\n        logging.info(f\"[_include_titles] Input schema:\\n{schema}\")\n\n    # Update first-level properties (that is, task arguments)\n    new_properties = _include_titles_for_properties(\n        schema[\"properties\"], verbose=verbose\n    )\n    new_schema[\"properties\"] = new_properties\n\n    if verbose:\n        logging.info(\"[_include_titles] Titles for properties now included.\")\n\n    # Update properties of definitions\n    if definitions_key in schema.keys():\n        new_definitions = schema[definitions_key].copy()\n        for def_name, def_schema in new_definitions.items():\n            if \"properties\" not in def_schema.keys():\n                if verbose:\n                    logging.info(\n                        f\"Definition schema {def_name} has no 'properties' \"\n                        \"key. Skip.\"\n                    )\n            else:\n                new_properties = _include_titles_for_properties(\n                    def_schema[\"properties\"], verbose=verbose\n                )\n                new_definitions[def_name][\"properties\"] = new_properties\n        new_schema[definitions_key] = new_definitions\n\n    if verbose:\n        logging.info(\n            \"[_include_titles] Titles for definitions properties now included.\"\n        )\n        logging.info(\"[_include_titles] END\")\n    return new_schema\n</code></pre>"},{"location":"reference/fractal_task_tools/_titles/#fractal_task_tools._titles._include_titles_for_properties","title":"<code>_include_titles_for_properties(properties, verbose=False)</code>","text":"<p>Scan through properties of a JSON Schema, and set their title when it is missing.</p> <p>The title is set to <code>name.title()</code>, where <code>title</code> is a standard string method - see https://docs.python.org/3/library/stdtypes.html#str.title.</p> PARAMETER DESCRIPTION <code>properties</code> <p>TBD</p> <p> TYPE: <code>dict[str, dict]</code> </p> Source code in <code>src/fractal_task_tools/_titles.py</code> <pre><code>def _include_titles_for_properties(\n    properties: dict[str, dict],\n    verbose: bool = False,\n) -&gt; dict[str, dict]:\n\"\"\"\n    Scan through properties of a JSON Schema, and set their title when it is\n    missing.\n\n    The title is set to `name.title()`, where `title` is a standard string\n    method - see https://docs.python.org/3/library/stdtypes.html#str.title.\n\n    Args:\n        properties: TBD\n    \"\"\"\n    if verbose:\n        logging.info(\n            f\"[_include_titles_for_properties] Original properties:\\n\"\n            f\"{properties}\"\n        )\n\n    new_properties = properties.copy()\n    for prop_name, prop in properties.items():\n        if \"title\" not in prop.keys():\n            new_prop = prop.copy()\n            new_prop[\"title\"] = prop_name.title()\n            new_properties[prop_name] = new_prop\n    if verbose:\n        logging.info(\n            f\"[_include_titles_for_properties] New properties:\\n\"\n            f\"{new_properties}\"\n        )\n    return new_properties\n</code></pre>"},{"location":"reference/fractal_task_tools/task_models/","title":"task_models","text":""},{"location":"reference/fractal_task_tools/task_models/#fractal_task_tools.task_models.CompoundTask","title":"<code>CompoundTask</code>","text":"<p>               Bases: <code>_BaseTask</code></p> <p>A <code>CompoundTask</code> object must include both <code>executable_init</code> and <code>executable</code> attributes, and it may include the <code>meta_init</code> and <code>meta</code> attributes.</p> Source code in <code>src/fractal_task_tools/task_models.py</code> <pre><code>class CompoundTask(_BaseTask):\n\"\"\"\n    A `CompoundTask` object must include both `executable_init` and\n    `executable` attributes, and it may include the `meta_init` and `meta`\n    attributes.\n    \"\"\"\n\n    executable_init: str\n    meta_init: Optional[dict[str, Any]] = None\n\n    @property\n    def executable_non_parallel(self) -&gt; str:\n        return self.executable_init\n\n    @property\n    def meta_non_parallel(self) -&gt; Optional[dict[str, Any]]:\n        return self.meta_init\n\n    @property\n    def executable_parallel(self) -&gt; str:\n        return self.executable\n\n    @property\n    def meta_parallel(self) -&gt; Optional[dict[str, Any]]:\n        return self.meta\n</code></pre>"},{"location":"reference/fractal_task_tools/task_models/#fractal_task_tools.task_models.NonParallelTask","title":"<code>NonParallelTask</code>","text":"<p>               Bases: <code>_BaseTask</code></p> <p>A <code>NonParallelTask</code> object must include the <code>executable</code> attribute, and it may include the <code>meta</code> attribute.</p> Source code in <code>src/fractal_task_tools/task_models.py</code> <pre><code>class NonParallelTask(_BaseTask):\n\"\"\"\n    A `NonParallelTask` object must include the `executable` attribute, and it\n    may include the `meta` attribute.\n    \"\"\"\n\n    @property\n    def executable_non_parallel(self) -&gt; str:\n        return self.executable\n\n    @property\n    def meta_non_parallel(self) -&gt; Optional[dict[str, Any]]:\n        return self.meta\n\n    @property\n    def executable_parallel(self) -&gt; None:\n        return None\n\n    @property\n    def meta_parallel(self) -&gt; None:\n        return None\n</code></pre>"},{"location":"reference/fractal_task_tools/task_models/#fractal_task_tools.task_models.ParallelTask","title":"<code>ParallelTask</code>","text":"<p>               Bases: <code>_BaseTask</code></p> <p>A <code>ParallelTask</code> object must include the <code>executable</code> attribute, and it may include the <code>meta</code> attribute.</p> Source code in <code>src/fractal_task_tools/task_models.py</code> <pre><code>class ParallelTask(_BaseTask):\n\"\"\"\n    A `ParallelTask` object must include the `executable` attribute, and it may\n    include the `meta` attribute.\n    \"\"\"\n\n    @property\n    def executable_non_parallel(self) -&gt; None:\n        return None\n\n    @property\n    def meta_non_parallel(self) -&gt; None:\n        return None\n\n    @property\n    def executable_parallel(self) -&gt; str:\n        return self.executable\n\n    @property\n    def meta_parallel(self) -&gt; Optional[dict[str, Any]]:\n        return self.meta\n</code></pre>"},{"location":"reference/fractal_task_tools/task_wrapper/","title":"task_wrapper","text":"<p>Standard input/output interface for tasks.</p>"},{"location":"reference/fractal_task_tools/task_wrapper/#fractal_task_tools.task_wrapper.TaskParameterEncoder","title":"<code>TaskParameterEncoder</code>","text":"<p>               Bases: <code>JSONEncoder</code></p> <p>Custom JSONEncoder that transforms Path objects to strings.</p> <p>Ref https://docs.python.org/3/library/json.html</p> Source code in <code>src/fractal_task_tools/task_wrapper.py</code> <pre><code>class TaskParameterEncoder(JSONEncoder):\n\"\"\"\n    Custom JSONEncoder that transforms Path objects to strings.\n\n    Ref https://docs.python.org/3/library/json.html\n    \"\"\"\n\n    def default(self, obj):\n        if isinstance(obj, Path):\n            return obj.as_posix()\n        return super().default(obj)\n</code></pre>"},{"location":"reference/fractal_task_tools/task_wrapper/#fractal_task_tools.task_wrapper.run_fractal_task","title":"<code>run_fractal_task(*, task_function, logger_name=None)</code>","text":"<p>Implement standard task interface and call task_function.</p> PARAMETER DESCRIPTION <code>task_function</code> <p>the callable function that runs the task.</p> <p> TYPE: <code>callable</code> </p> <code>logger_name</code> <p>TBD</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> Source code in <code>src/fractal_task_tools/task_wrapper.py</code> <pre><code>def run_fractal_task(\n    *,\n    task_function: callable,\n    logger_name: Optional[str] = None,\n):\n\"\"\"\n    Implement standard task interface and call task_function.\n\n    Args:\n        task_function: the callable function that runs the task.\n        logger_name: TBD\n    \"\"\"\n\n    # Parse `-j` and `--metadata-out` arguments\n    parser = ArgumentParser()\n    parser.add_argument(\n        \"--args-json\", help=\"Read parameters from json file\", required=True\n    )\n    parser.add_argument(\n        \"--out-json\",\n        help=\"Output file to redirect serialised returned data\",\n        required=True,\n    )\n    parsed_args = parser.parse_args()\n\n    # Set logger\n    logger = logging.getLogger(logger_name)\n\n    # Preliminary check\n    if Path(parsed_args.out_json).exists():\n        logger.error(\n            f\"Output file {parsed_args.out_json} already exists. Terminating\"\n        )\n        exit(1)\n\n    # Read parameters dictionary\n    with open(parsed_args.args_json, \"r\") as f:\n        pars = json.load(f)\n\n    # Run task\n    logger.info(f\"START {task_function.__name__} task\")\n    metadata_update = task_function(**pars)\n    logger.info(f\"END {task_function.__name__} task\")\n\n    # Write output metadata to file, with custom JSON encoder\n    with open(parsed_args.out_json, \"w\") as fout:\n        json.dump(metadata_update, fout, cls=TaskParameterEncoder, indent=2)\n</code></pre>"}]}